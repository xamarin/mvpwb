---
uti: com.xamarin.workbook
platforms:
- Console
---

# 101 (and then some) LINQ Examples

Language Integrated Query provides a consistent query syntax across a variety of data sources and formats.  In a LINQ query, you are always working with objects. You use the same basic coding patterns to query and transform data in XML documents, SQL databases, Datasets, .NET collections, and any other format for which a LINQ provider is available.

```csharp
//Support classes
#load "101_Linq_Examples.csx"
```

## Restriction Operators

These examples show different uses of Restriction Operators:

### Where - Simple 1

This example finds all elements of an array less than 5

```csharp
int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };

var lowNums =
    from num in numbers
    where num < 5
    select num;
```

### Where - Simple 2

This example finds all products that are out of stock.

```csharp
List<Product> products = productList;

var soldOutProducts =
    from prod in products
    where prod.UnitsInStock == 0
    select prod;

Console.WriteLine("Sold out products:");
foreach (var product in soldOutProducts)
{
    Console.WriteLine($"{product.ProductName} is sold out.");
};
soldOutProducts
```

### Where - Simple 3

This example finds all products that are in stock and cost more than 3.00 per unit.

```csharp
var expensiveInStockProducts =
                    from prod in products
                    where prod.UnitsInStock > 0 && prod.UnitPrice > 3.00M
                    select prod;
Console.WriteLine("In-stock products that cost more than $3.00:");
foreach (var product in expensiveInStockProducts)
{
    Console.WriteLine($"{product.ProductName} is in stock and costs ${product.UnitPrice:N2}.");
}
expensiveInStockProducts
```

### Where - Drilldown

This example finds all customers in Washington and then uses the resulting sequence to drill down into their orders.

```csharp
var waCustomers =
    from cust in customerList
    where cust.Region == "WA"
    select cust;

Console.WriteLine("Customers from Washington and their orders:");
foreach (var customer in waCustomers)
{
    Console.WriteLine("Customer {0}: {1}", customer.CustomerID, customer.CompanyName);
    foreach (var order in customer.Orders)
    {
        Console.WriteLine("  Order {0}: {1}", order.OrderID, order.OrderDate);
    }
}
waCustomers
```

### Where - Indexed

This example shows an indexed Where clause that returns digits whose name is shorter than their value.

```csharp
string[] digits = { "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine" };

var shortDigits = digits.Where((digit, index) => digit.Length < index);

Console.WriteLine("Short digits:");
foreach (var d in shortDigits)
{
    Console.WriteLine($"The word {d} is shorter than its value.");

}
```

## Projection Operators

These samples shows different uses of Projection Operators

### Select - Simple 1

This sample uses `select` to produce a sequence of ints one higher than those in an existing array of ints.

```csharp
using System.Data;
using System.Linq;

var numbers = testDS.Tables["Numbers"].AsEnumerable();

var numsPlusOne =
    from n in numbers
    select n.Field<int>(0) + 1;

Console.WriteLine("Numbers and their successors:");
TestHelper.ZipToStrings<DataRow,int>(numbers, numsPlusOne, (a,b)=>$"{a.Field<int>(0)} + 1 = {b}");
```

### Select - Simple 2

This sample uses `select` to return a sequence of just the names of a list of products.

```csharp
var products = testDS.Tables["Products"].AsEnumerable();

var productNames =
    from p in products
    select p.Field<string>("ProductName");

Console.WriteLine("Product Names:");
foreach (var productName in productNames)
{
    Console.WriteLine(productName);
}
```

### Select - Transformation

This sample uses `select` to produce a sequence of strings representing the text version of a sequence of ints.

```csharp
var numbers = testDS.Tables["Numbers"].AsEnumerable();
var strings = new [] { "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine" };

var textNums = numbers.Select(p => strings[p.Field<int>("number")]);

Console.WriteLine("Number strings:");
TestHelper.ZipToStrings<DataRow, string>(numbers, textNums, (a,b)=>$"String at index [{a.Field<int>("number")}] is {b}");
```

### Select - Anonymous Types 1

This sample uses `select` to produce a sequence of the uppercase and lowercase versions of each word in the original array

```csharp
var words = testDS.Tables["Words"].AsEnumerable();

var upperLowerWords = words.Select(p => new
{
    Upper = (p.Field<string>(0)).ToUpper(),
    Lower = (p.Field<string>(0)).ToLower()
});

foreach (var ul in upperLowerWords)
{
    Console.WriteLine("Uppercase: " + ul.Upper + ", Lowercase: " + ul.Lower);
}
```

### Select - Anonymous Types 2

This sample uses `select` to produce a sequence containing text representations of digits and whether their length is even or odd.

```csharp
var numbers = testDS.Tables["Numbers"].AsEnumerable();
var digits = testDS.Tables["Digits"];
string[] strings = { "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine" };

var digitOddEvens = numbers.
    Select(n => new
    {
        Digit = digits.Rows[n.Field<int>("number")]["digit"],
        Even = (n.Field<int>("number") % 2 == 0)
    });

foreach (var d in digitOddEvens)
{
    Console.WriteLine("The digit {0} is {1}.", d.Digit, d.Even ? "even" : "odd");
}
```

### Select - Anonymous Types 3

This sample uses `select` to produce a sequence containing some properties of `Products`, including `UnitPrice` which is renamed to `Price` in the resulting type.

```csharp
var products = testDS.Tables["Products"].AsEnumerable();

var productInfos = products.
    Select(n => new
    {
        ProductName = n.Field<string>("ProductName"),
        Category = n.Field<string>("Category"),
        Price = n.Field<decimal>("UnitPrice")
    });

Console.WriteLine("Product Info:");
foreach (var productInfo in productInfos)
{
    Console.WriteLine($"{productInfo.ProductName} is in the category {productInfo.Category} and costs ${productInfo.Price:N2} per unit.");
}
```

### Select - Indexed

This sample uses an indexed `Select` clause to determine if the value of ints in an array match their position in the array.

```csharp
var numbers = testDS.Tables["Numbers"].AsEnumerable();

var numsInPlace = numbers.Select((num, index) => new
{
    Num = num.Field<int>("number"),
    InPlace = (num.Field<int>("number") == index)
});

Console.WriteLine("Number: In-place:");
foreach (var n in numsInPlace)
{
    Console.WriteLine("{0}: {1}", n.Num, n.InPlace);
}
```

### Select - Filtered

This sample combines `select` and `where` to make a simple query that returns the text form of each digit less than 5.

```csharp
var numbers = testDS.Tables["Numbers"].AsEnumerable();
var digits = testDS.Tables["Digits"];

var lowNums =
    from n in numbers
    where n.Field<int>("number") < 5
    select digits.Rows[n.Field<int>("number")].Field<string>("digit");

Console.WriteLine("Numbers < 5:");
foreach (var num in lowNums)
{
    Console.WriteLine(num);
}
```

### SelectMany - Compound from 1

This sample uses a compound `from` clause to make a query that returns all pairs of numbers from both arrays such that the number from `numbersA` is less than the number from `numbersB`.

```csharp
var numbersA = testDS.Tables["NumbersA"].AsEnumerable();
var numbersB = testDS.Tables["NumbersB"].AsEnumerable();

var pairs =
    from a in numbersA
    from b in numbersB
    where a.Field<int>("number") < b.Field<int>("number")
    select new { a = a.Field<int>("number"), b = b.Field<int>("number") };

Console.WriteLine("Pairs where a < b:");
foreach (var pair in pairs)
{
    Console.WriteLine("{0} is less than {1}", pair.a, pair.b);
}
```

### SelectMany - Compound from 2

This sample uses a compound `from` clause to select all orders where the order total is less than 500.00.

```csharp
var customers = testDS.Tables["Customers"].AsEnumerable();
var orders = testDS.Tables["Orders"].AsEnumerable();

var smallOrders =
    from c in customers
    from o in orders
    where c.Field<string>("CustomerID") == o.Field<string>("CustomerID")
        && o.Field<decimal>("Total") < 500.00M
    select new
    {
        CustomerID = c.Field<string>("CustomerID"),
        OrderID = o.Field<int>("OrderID"),
        Total = o.Field<decimal>("Total")
    };
```

### SelectMany - Compound from 3

This sample uses a compound `from` clause to select all orders where the order was made in 1998 or later.

```csharp
var customers = testDS.Tables["Customers"].AsEnumerable();
var orders = testDS.Tables["Orders"].AsEnumerable();

var myOrders =
    from c in customers
    from o in orders
    where c.Field<string>("CustomerID") == o.Field<string>("CustomerID") &&
    o.Field<DateTime>("OrderDate") >= new DateTime(1998, 1, 1)
    select new
    {
        CustomerID = c.Field<string>("CustomerID"),
        OrderID = o.Field<int>("OrderID"),
        OrderDate = o.Field<DateTime>("OrderDate")
    };
```

### SelectMany - from Assignment

This sample uses a compound `from` clause to select all orders where the order total is greater than 2000.00 and uses `from` assignment to avoid requesting the total twice.

```csharp
var customers = testDS.Tables["Customers"].AsEnumerable();
var orders = testDS.Tables["Orders"].AsEnumerable();

var myOrders =
    from c in customers
    from o in orders
    let total = o.Field<decimal>("Total")
    where c.Field<string>("CustomerID") == o.Field<string>("CustomerID")
        && total >= 2000.0M
    select new { CustomerID = c.Field<string>("CustomerID"), OrderID = o.Field<int>("OrderID"), total };
```

### SelectMany - Multiple from

This sample uses multiple `from` clauses so that filtering on customers can be done before selecting their orders.  This makes the query more efficient by not selecting and then discarding orders for customers outside of Washington.

```csharp
var customers = testDS.Tables["Customers"].AsEnumerable();
var orders = testDS.Tables["Orders"].AsEnumerable();
DateTime cutoffDate = new DateTime(1997, 1, 1);

var myOrders =
    from c in customers
    where c.Field<string>("Region") == "WA"
    from o in orders
    where c.Field<string>("CustomerID") == o.Field<string>("CustomerID")
    && (DateTime)o["OrderDate"] >= cutoffDate
    select new { CustomerID = c.Field<string>("CustomerID"), OrderID = o.Field<int>("OrderID") };
```

### SelectMany - Indexed

This sample uses an indexed `SelectMany` clause to select all orders, while referring to customers by the order in which they are returned from the query.

```csharp
var customers = testDS.Tables["Customers"].AsEnumerable();
var orders = testDS.Tables["Orders"].AsEnumerable();

var customerOrders =
    customers.SelectMany(
        (cust, custIndex) =>
        orders.Where(o => cust.Field<string>("CustomerID") == o.Field<string>("CustomerID"))
            .Select(o => new { CustomerIndex = custIndex + 1, OrderID = o.Field<int>("OrderID") }));
```

## Partitioning Operators

These samples show different uses of Partitioning Operators

### Take - Simple

This sample uses `Take` to get only the first 3 elements of the array.

```csharp
int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };

var first3Numbers = numbers.Take(3);
```

## Take - Nested

This sample uses `Take` to get the first 3 orders from customers in Washington.

```csharp
List<Customer> customers = customerList;

var first3WAOrders = (
    from cust in customers
    from order in cust.Orders
    where cust.Region == "WA"
    select new { cust.CustomerID, order.OrderID, order.OrderDate })
    .Take(3);
```

## Skip - Simple

This sample uses `Skip` to get all but the first four elements of the array.

```csharp
int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };

var allButFirst4Numbers = numbers.Skip(4);

Console.WriteLine("All but first 4 numbers:");
foreach (var n in allButFirst4Numbers)
{
    Console.WriteLine(n);
}
```

## Skip - Nested

This sample uses `Skip` to get all but the first 2 orders from customers in Washington.

```csharp
List<Customer> customers = customerList;

var waOrders =
    from cust in customers
    from order in cust.Orders
    where cust.Region == "WA"
    select new { cust.CustomerID, order.OrderID, order.OrderDate };

var allButFirst2Orders = waOrders.Skip(2);
```

## TakeWhile - Simple

This sample uses `TakeWhile` to return elements starting from the beginning of the array until a number is read whose value is not less than 6.

```csharp
int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };

var firstNumbersLessThan6 = numbers.TakeWhile(n => n < 6);
```

## TakeWhile - Indexed

This sample uses `TakeWhile` to return elements starting from the beginning of the array until a number is hit that is less than its position in the array.

```csharp
int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };

var firstSmallNumbers = numbers.TakeWhile((n, index) => n >= index);
```

## SkipWhile - Simple

This sample uses `SkipWhile` to get the elements of the array starting from the first element divisible by 3.

```csharp
int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };

// In the lambda expression, 'n' is the input parameter that identifies each
// element in the collection in succession. It is is inferred to be
// of type int because numbers is an int array.
var allButFirst3Numbers = numbers.SkipWhile(n => n % 3 != 0);
```

## SkipWhile - Indexed

This sample uses `SkipWhile` to get the elements of the array starting from the first element less than its position.

```csharp
int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };

var laterNumbers = numbers.SkipWhile((n, index) => n >= index);
```

## Ordering operators

These samples show different uses of Ordering Operators.

### OrderBy - Simple 1

This sample uses `orderby` to sort a list of words alphabetically.

```csharp
string[] words = { "cherry", "apple", "blueberry" };

var sortedWords =
    from word in words
    orderby word
    select word;
```

### OrderBy - Simple 2

This sample uses `orderby` to sort a list of words by length.

```csharp
string[] words = { "cherry", "apple", "blueberry" };

var sortedWords =
    from word in words
    orderby word.Length
    select word;
```

### OrderBy - Simple 3

This sample uses `orderby` to sort a list of products by name.

Use the "descending" keyword at the end of the clause to perform a reverse ordering

```csharp
List<Product> products = productList;

var sortedProducts =
    from prod in products
    orderby prod.ProductName
    select prod;
```

### OrderBy - Comparer

This sample uses an `OrderBy` clause with a custom comparer to do a case-insensitive sort of the words in an array.

```csharp
// Custom comparer for use with ordering operators
public class CaseInsensitiveComparer : IComparer<string>
{
    public int Compare(string x, string y)
    {
        return string.Compare(x, y, StringComparison.OrdinalIgnoreCase);
    }
}

string[] words = { "aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry" };

var sortedWords = words.OrderBy(a => a, new CaseInsensitiveComparer());
```

### OrderByDescending - Simple 1

This sample uses `orderby` and `descending` to sort a list of doubles from highest to lowest.

```csharp
double[] doubles = { 1.7, 2.3, 1.9, 4.1, 2.9 };

var sortedDoubles =
    from d in doubles
    orderby d descending
    select d;
```

### OrderByDescending - Simple 2

This sample uses `orderby` to sort a list of products by units in stock from highest to lowest.

```csharp
List<Product> products = productList;

var sortedProducts =
    from prod in products
    orderby prod.UnitsInStock descending
    select prod
```

### OrderByDescending - Comparer

This sample uses method syntax to call `OrderByDescending` because it enables you to use a custom comparer.

```csharp
string[] words = { "aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry" };

var sortedWords = words.OrderByDescending(a => a, new CaseInsensitiveComparer());
```

### ThenBy - Simple

This sample uses a compound `orderby` to sort a list of digits, first by length of their name, and then alphabetically by the name itself.

```csharp
string[] digits = { "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine" };

var sortedDigits =
    from digit in digits
    orderby digit.Length, digit
    select digit;
```

### ThenBy - Comparer

The first query in this sample uses method syntax to call `OrderBy` and `ThenBy` with a custom comparer to sort first by word length and then by a case-insensitive sort of the words in an array.

The second two queries show another way to perform the same task.

```csharp
string[] words = { "aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry" };

var sortedWords =
    words.OrderBy(a => a.Length)
         .ThenBy(a => a, new CaseInsensitiveComparer());
```

Alternative:

```csharp
// Another way. TODO is this use of ThenBy correct? It seems to work on this sample array.
var sortedWords2 =
    from word in words
    orderby word.Length
    select word;
```

Another alternative:

```csharp
var sortedWords3 = sortedWords2.ThenBy(a => a, new CaseInsensitiveComparer());
```

### ThenByDescending - Simple

This sample uses a compound `orderby` to sort a list of products, first by category, and then by unit price, from highest to lowest.

```csharp
List<Product> products = productList;

var sortedProducts =
    from prod in products
    orderby prod.Category, prod.UnitPrice descending
    select prod;
```

### ThenByDescending - Comparer

This sample uses an `OrderBy` and a `ThenBy` clause with a custom comparer to sort first by word length and then by a case-insensitive descending sort of the words in an array.

```csharp
string[] words = { "aPPLE", "AbAcUs", "bRaNcH", "BlUeBeRrY", "ClOvEr", "cHeRry" };

var sortedWords =
    words.OrderBy(a => a.Length)
         .ThenByDescending(a => a, new CaseInsensitiveComparer());
```

### Reverse

This sample uses `Reverse` to create a list of all digits in the array whose second letter is 'i' that is reversed from the order in the original array.

```csharp
string[] digits = { "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine" };

var reversedIDigits = (
    from digit in digits
    where digit[1] == 'i'
    select digit)
    .Reverse();
```

## Grouping Operators

These samples shows different uses of Grouping Operators.

### GroupBy - Simple 1

This sample uses `group by` to partition a list of numbers by their remainder when divided by 5.

```csharp
var numbers = testDS.Tables["Numbers"].AsEnumerable();

var numberGroups =
    from n in numbers
    group n by n.Field<int>("number") % 5 into g
    select new { Remainder = g.Key, Numbers = g };

foreach (var g in numberGroups)
{
    Console.WriteLine("Numbers with a remainder of {0} when divided by 5:", g.Remainder);
    foreach (var n in g.Numbers)
    {
        Console.WriteLine(n.Field<int>("number"));
    }
}
```

### GroupBy - Simple 2

This sample uses `group by` to partition a list of words by their first letter.

```csharp
var words4 = testDS.Tables["Words4"].AsEnumerable();

var wordGroups =
    from w in words4
    group w by w.Field<string>("word")[0] into g
    select new { FirstLetter = g.Key, Words = g };

foreach (var g in wordGroups)
{
    Console.WriteLine("Words that start with the letter '{0}':", g.FirstLetter);
    foreach (var w in g.Words)
    {
        Console.WriteLine(w.Field<string>("word"));
    }
}
```

### GroupBy - Simple 3

This sample uses `group by` to partition a list of products by category.

```csharp
var products = testDS.Tables["Products"].AsEnumerable();

var productGroups =
    from p in products
    group p by p.Field<string>("Category") into g
    select new { Category = g.Key, Products = g };

foreach (var g in productGroups)
{
    Console.WriteLine("Category: {0}", g.Category);
    foreach (var w in g.Products)
    {
        Console.WriteLine("\t" + w.Field<string>("ProductName"));
    }
}
```

### GroupBy - Nested

This sample uses `group by` to partition a list of each customer's orders, first by year, and then by month.

```csharp
var customers = testDS.Tables["Customers"].AsEnumerable();

var customerOrderGroups =
    from c in customers
    select
        new
        {
            CompanyName = c.Field<string>("CompanyName"),
            YearGroups =
                from o in c.GetChildRows("CustomersOrders")
                group o by o.Field<DateTime>("OrderDate").Year into yg
                select
                    new
                    {
                        Year = yg.Key,
                        MonthGroups =
                            from o in yg
                            group o by o.Field<DateTime>("OrderDate").Month into mg
                            select new { Month = mg.Key, Orders = mg }
                    }
        };

foreach (var cog in customerOrderGroups)
{
    Console.WriteLine("CompanyName= {0}", cog.CompanyName);
    foreach (var yg in cog.YearGroups)
    {
        Console.WriteLine("\t Year= {0}", yg.Year);
        foreach (var mg in yg.MonthGroups)
        {
            Console.WriteLine("\t\t Month= {0}", mg.Month);
            foreach (var order in mg.Orders)
            {
                Console.WriteLine("\t\t\t OrderID= {0} ", order.Field<int>("OrderID"));
                Console.WriteLine("\t\t\t OrderDate= {0} ", order.Field<DateTime>("OrderDate"));
            }
        }
    }
}
```

### GroupBy - Comparer

This sample uses `GroupBy` to partition trimmed elements of an array using a custom comparer that matches words that are anagrams of each other.

```csharp
private class AnagramEqualityComparer : IEqualityComparer<string>
{
    public bool Equals(string x, string y)
    {
        return getCanonicalString(x) == getCanonicalString(y);
    }

    public int GetHashCode(string obj)
    {
        return getCanonicalString(obj).GetHashCode();
    }

    private string getCanonicalString(string word)
    {
        char[] wordChars = word.ToCharArray();
        Array.Sort<char>(wordChars);
        return new string(wordChars);
    }
}

var anagrams = testDS.Tables["Anagrams"].AsEnumerable();

var orderGroups = anagrams.GroupBy(w => w.Field<string>("anagram").Trim(), new AnagramEqualityComparer());

foreach (var g in orderGroups)
{
    Console.WriteLine("Key: {0}", g.Key);
    foreach (var w in g)
    {
        Console.WriteLine($"\t has the anagram: {w.Field<string>("anagram")}");
    }
}
```

### GroupBy - Comparer, Mapped

This sample uses `GroupBy` to partition trimmed elements of an array using a custom comparer that matches words that are anagrams of each other, and then converts the results to uppercase.

```csharp
var anagrams = testDS.Tables["Anagrams"].AsEnumerable();

var orderGroups = anagrams.GroupBy(
    w => w.Field<string>("anagram").Trim(),
    a => a.Field<string>("anagram").ToUpper(),
    new AnagramEqualityComparer()
    );

foreach (var g in orderGroups)
{
    Console.WriteLine("Key: {0}", g.Key);
    foreach (var w in g)
    {
        Console.WriteLine("\t" + w);
    }
}
```

## Set Operators

These samples show different uses of Set Operators.

### Distinct - 1

This sample uses `Distinct` to remove duplicate elements in a sequence of factors of 300.

```csharp
int[] factorsOf300 = { 2, 2, 3, 5, 5 };

var uniqueFactors = factorsOf300.Distinct();
```

### Distinct - 2

This sample uses `Distinct` to find the unique Category names.

```csharp
List<Product> products = productList;

var categoryNames = (
    from prod in products
    select prod.Category)
    .Distinct();
```

### Union - 1

This sample uses `Union` to create one sequence that contains the unique values from both arrays.

```csharp
int[] numbersA = { 0, 2, 4, 5, 6, 8, 9 };
int[] numbersB = { 1, 3, 5, 7, 8 };

var uniqueNumbers = numbersA.Union(numbersB);
```

### Union - 2

This sample uses `Union` to create one sequence that contains the unique first letter from both product and customer names.

```csharp
List<Product> products = GetProductList();
List<Customer> customers = GetCustomerList();

var productFirstChars =
    from prod in products
    select prod.ProductName[0];
var customerFirstChars =
    from cust in customers
    select cust.CompanyName[0];

var uniqueFirstChars = productFirstChars.Union(customerFirstChars);
```

### Intersect - 1

This sample uses `Intersect` to create one sequence that contains the common values shared by both arrays.

```csharp
int[] numbersA = { 0, 2, 4, 5, 6, 8, 9 };
int[] numbersB = { 1, 3, 5, 7, 8 };

var commonNumbers = numbersA.Intersect(numbersB);
```

### Intersect - 2

This sample uses `Intersect` to create one sequence that contains the common first letter from both product and customer names.

```csharp
List<Product> products = GetProductList();
List<Customer> customers = GetCustomerList();

var productFirstChars =
    from prod in products
    select prod.ProductName[0];
var customerFirstChars =
    from cust in customers
    select cust.CompanyName[0];

var commonFirstChars = productFirstChars.Intersect(customerFirstChars);
```

### Except - 1

This sample uses `Except` to create a sequence that contains the values from `numbersA` that are not also in `numbersB`.

```csharp
int[] numbersA = { 0, 2, 4, 5, 6, 8, 9 };
int[] numbersB = { 1, 3, 5, 7, 8 };

IEnumerable<int> aOnlyNumbers = numbersA.Except(numbersB);
```

### Except - 2

This sample uses `Except` to create one sequence that contains the first letters of product names that are not also first letters of customer names.

```csharp
List<Product> products = GetProductList();
List<Customer> customers = GetCustomerList();

var productFirstChars =
    from prod in products
    select prod.ProductName[0];
var customerFirstChars =
    from cust in customers
    select cust.CompanyName[0];

var productOnlyFirstChars = productFirstChars.Except(customerFirstChars);
```

## Conversion Operators

These samples show different uses of Conversion Operators.

### ToArray

This sample uses `ToArray` to immediately evaluate a sequence into an array.

```csharp
double[] doubles = { 1.7, 2.3, 1.9, 4.1, 2.9 };

var sortedDoubles =
    from d in doubles
    orderby d descending
    select d;
var doublesArray = sortedDoubles.ToArray();

Console.WriteLine("Every other double from highest to lowest:");
for (int d = 0; d < doublesArray.Length; d += 2)
{
    Console.WriteLine(doublesArray[d]);
}
```

### ToList

This sample uses `ToList` to immediately evaluate a sequence into a `List<T>`.

```csharp
string[] words = { "cherry", "apple", "blueberry" };

var sortedWords =
    from w in words
    orderby w
    select w;
var wordList = sortedWords.ToList();

Console.WriteLine("The sorted word list:");
foreach (var w in wordList)
{
    Console.WriteLine(w);
}
```

### ToDictionary

This sample uses `ToDictionary` to immediately evaluate a sequence and a related key expression into a dictionary.

```csharp
var scoreRecords = new[] { new {Name = "Alice", Score = 50},
                            new {Name = "Bob"  , Score = 40},
                            new {Name = "Cathy", Score = 45}
                        };

var scoreRecordsDict = scoreRecords.ToDictionary(sr => sr.Name);

Console.WriteLine("Bob's score: {0}", scoreRecordsDict["Bob"]);
```

### OfType

This sample uses `OfType` to return only the elements of the array that are of type double.

```csharp
object[] numbers = { null, 1.0, "two", 3, "four", 5, "six", 7.0 };

var doubles = numbers.OfType<double>();
```

## Element Operators

These samples show different uses of Element Operators

### First - Simple

This sample uses `First` to return the first matching element as a `Product`.

```csharp
List<Product> products = GetProductList();

Product product12 = (
    from prod in products
    where prod.ProductID == 12
    select prod)
    .First();
```

### First - Condition

This sample uses `First` to find the first element in the array that starts with 'o'.

```csharp
string[] strings = { "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine" };

string startsWithO = strings.First(s => s[0] == 'o');
```

### FirstOrDefault - Simple

This sample uses `FirstOrDefault` to try to return the first element of the sequence, unless there are no elements, in which case the default value for that type is returned. `FirstOrDefault` is useful for creating outer joins.

```csharp
int[] numbers = { };

int firstNumOrDefault = numbers.FirstOrDefault();
```

### FirstOrDefault - Condition

This sample uses `FirstOrDefault` to return the first product whose ProductID is 789 as a single `Product` object, unless there is no match, in which case `null` is returned.

```csharp
List<Product> products = GetProductList();

Product product789 = products.FirstOrDefault(p => p.ProductID == 789);

Console.WriteLine("Product 789 exists: {0}", product789 != null);
```

### ElementAt

This sample uses `ElementAt` to retrieve the second number greater than 5 from an array.

```csharp
int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };

int fourthLowNum = (
    from num in numbers
    where num > 5
    select num)
    .ElementAt(1);  // second number is index 1 because sequences use 0-based indexing

Console.WriteLine("Second number > 5: {0}", fourthLowNum);
```

## Generation Operators

These samples show different uses of Generation Operators.

### Range

This sample uses `Range` to generate a sequence of numbers from 100 to 149 that is used to find which numbers in that range are odd and even.

```csharp
var numbers =
    from n in Enumerable.Range(100, 50)
    select new { Number = n, OddEven = n % 2 == 1 ? "odd" : "even" };

foreach (var n in numbers)
{
    Console.WriteLine("The number {0} is {1}.", n.Number, n.OddEven);
}
```

### Repeat

This sample uses `Repeat` to generate a sequence that contains the number 7 ten times.

```csharp
var numbers = Enumerable.Repeat(7, 10);

foreach (var n in numbers)
{
    Console.WriteLine(n);
}
```

## Quantifiers

These samples show different uses of Quantifiers.

### Any - Simple

This sample uses `Any`to determine if any of the words in the array contain the substring 'ei'.

```csharp
string[] words = { "believe", "relief", "receipt", "field" };

bool iAfterE = words.Any(w => w.Contains("ei"));
```

### Any - Grouped

This sample uses `Any` to return a grouped a list of products only for categories that have at least one product that is out of stock.

```csharp
List<Product> products = GetProductList();

var productGroups =
    from prod in products
    group prod by prod.Category into prodGroup
    where prodGroup.Any(p => p.UnitsInStock == 0)
    select new { Category = prodGroup.Key, Products = prodGroup };
```

### All - Simple

This sample uses `All` to determine whether an array contains only odd numbers.

```csharp
int[] numbers = { 1, 11, 3, 19, 41, 65, 19 };

bool onlyOdd = numbers.All(n => n % 2 == 1);
```

### All - Grouped

This sample uses `All` to return a grouped a list of products only for categories that have all of their products in stock.

```csharp
List<Product> products = GetProductList();

var productGroups =
    from prod in products
    group prod by prod.Category into prodGroup
    where prodGroup.All(p => p.UnitsInStock > 0)
    select new { Category = prodGroup.Key, Products = prodGroup };
```

## Aggregate Operators

These samples show different uses of Aggregate Operators

### Count - Simple

This sample uses `Count` to get the number of unique factors of 300.

```csharp
int[] primeFactorsOf300 = { 2, 2, 3, 5, 5 };

int uniqueFactors = primeFactorsOf300.Distinct().Count();

Console.WriteLine("There are {0} unique prime factors of 300.", uniqueFactors);
```

### Count - Conditional

This sample uses `Count` to get the number of odd ints in the array.

```csharp
int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };

int oddNumbers = numbers.Count(n => n % 2 == 1);

Console.WriteLine("There are {0} odd numbers in the list.", oddNumbers);
```

### Count - Nested

This sample uses `Count` to return a list of customers and how many orders each has.

```csharp
List<Customer> customers = GetCustomerList();

var orderCounts =
    from cust in customers
    select new { cust.CustomerID, OrderCount = cust.Orders.Count() };
```

### Count - Grouped

This sample uses `Count`to return a list of categories and how many products each has.

```csharp
List<Product> products = GetProductList();

var categoryCounts =
    from prod in products
    group prod by prod.Category into prodGroup
    select new { Category = prodGroup.Key, ProductCount = prodGroup.Count() };
```

### Sum - Simple

This sample uses `Sum` to add all the numbers in an array.

```csharp
int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };

double numSum = numbers.Sum();
```

### Sum - Projection

This sample uses `Sum` to get the total number of characters of all words in the array.

```csharp
string[] words = { "cherry", "apple", "blueberry" };

double totalChars = words.Sum(w => w.Length);
```

### Sum - Grouped

This sample uses `Sum` to get the total units in stock for each product category.

```csharp
List<Product> products = GetProductList();

var categories =
    from prod in products
    group prod by prod.Category into prodGroup
    select new { Category = prodGroup.Key, TotalUnitsInStock = prodGroup.Sum(p => p.UnitsInStock) };
```

### Min - Simple

This sample uses `Min` to get the lowest number in an array.

```csharp
int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };

int minNum = numbers.Min();
```

### Min - Projection

This sample uses `Min` to get the length of the shortest word in an array.

```csharp
string[] words = { "cherry", "apple", "blueberry" };

int shortestWord = words.Min(w => w.Length);
```

### Min - Grouped

This sample uses `Min` to get the cheapest price among each category's products.

```csharp
List<Product> products = GetProductList();

var categories =
    from prod in products
    group prod by prod.Category into prodGroup
    select new { Category = prodGroup.Key, CheapestPrice = prodGroup.Min(p => p.UnitPrice) };
```

### Min - Elements

This sample uses `Min` to get the products with the cheapest price in each category.

```csharp
List<Product> products = GetProductList();

var categories =
    from prod in products
    group prod by prod.Category into prodGroup
    let minPrice = prodGroup.Min(p => p.UnitPrice)
    select new { Category = prodGroup.Key, CheapestProducts = prodGroup.Where(p => p.UnitPrice == minPrice) };
```

### Max - Simple

This sample uses `Max` to get the highest number in an array.

```csharp
int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };

int maxNum = numbers.Max();
```

### Max - Projection

This sample uses `Max` to get the length of the longest word in an array.

```csharp
string[] words = { "cherry", "apple", "blueberry" };

int longestLength = words.Max(w => w.Length);
```

### Max - Grouped

This sample uses `Max` to get the most expensive price among each category's products.

```csharp
List<Product> products = GetProductList();

var categories =
    from prod in products
    group prod by prod.Category into prodGroup
    select new { Category = prodGroup.Key, MostExpensivePrice = prodGroup.Max(p => p.UnitPrice) };
```

### Max - Elements

This sample uses `Max` to get the products with the most expensive price in each category.

```csharp
List<Product> products = GetProductList();

var categories =
    from prod in products
    group prod by prod.Category into prodGroup
    let maxPrice = prodGroup.Max(p => p.UnitPrice)
    select new { Category = prodGroup.Key, MostExpensiveProducts = prodGroup.Where(p => p.UnitPrice == maxPrice) };
```

### Average - Simple

This sample uses `Average` to get the average of all numbers in an array.

```csharp
int[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };

double averageNum = numbers.Average();
```

### Average - Projection

This sample uses `Average` to get the average length of the words in the array.

```csharp
string[] words = { "cherry", "apple", "blueberry" };

double averageLength = words.Average(w => w.Length);
```

### Average - Grouped

This sample uses `Average` to get the average price of each category's products.

```csharp
List<Product> products = GetProductList();

var categories =
    from prod in products
    group prod by prod.Category into prodGroup
    select new { Category = prodGroup.Key, AveragePrice = prodGroup.Average(p => p.UnitPrice) };
```

### Aggregate - Simple

This sample uses `Aggregate` to create a running product on the array that calculates the total product of all elements.

```csharp
double[] doubles = { 1.7, 2.3, 1.9, 4.1, 2.9 };

double product = doubles.Aggregate((runningProduct, nextFactor) => runningProduct * nextFactor);
```

### Aggregate - Seed

This sample uses `Aggregate` to create a running account balance that subtracts each withdrawal from the initial balance of 100, as long as the balance never drops below 0.

```csharp
double startBalance = 100.0;

int[] attemptedWithdrawals = { 20, 10, 40, 50, 10, 70, 30 };

double endBalance =
    attemptedWithdrawals.Aggregate(startBalance,
        (balance, nextWithdrawal) =>
            ((nextWithdrawal <= balance) ? (balance - nextWithdrawal) : balance));
```

## Miscellaneous Operators

These samples show different uses of Miscellaneous Operators.

### Concat - 1

This sample uses `Concat` to create one sequence that contains each array's values, one after the other.

```csharp
int[] numbersA = { 0, 2, 4, 5, 6, 8, 9 };
int[] numbersB = { 1, 3, 5, 7, 8 };

var allNumbers = numbersA.Concat(numbersB);
```

### Concat - 2

This sample uses `Concat` to create one sequence that contains the names of all customers and products, including any duplicates.

```csharp
List<Customer> customers = GetCustomerList();
List<Product> products = GetProductList();

var customerNames =
    from cust in customers
    select cust.CompanyName;
var productNames =
    from prod in products
    select prod.ProductName;

var allNames = customerNames.Concat(productNames);
```

### EqualAll - 1

This sample uses `SequenceEquals` to see if two sequences match on all elements in the same order.

```csharp
var wordsA = new string[] { "cherry", "apple", "blueberry" };
var wordsB = new string[] { "cherry", "apple", "blueberry" };

bool match = wordsA.SequenceEqual(wordsB);
```

### EqualAll - 2

This sample uses `SequenceEqual` to see if two sequences match on all elements in the same order.

```csharp
var wordsA = new string[] { "cherry", "apple", "blueberry" };
var wordsB = new string[] { "apple", "blueberry", "cherry" };

bool match = wordsA.SequenceEqual(wordsB);
```

## Custom Sequence Operators

This sample shows the use of a Custom Sequence Operator. It calculates the dot product of two integer vectors.

```csharp
public static IEnumerable<S> Combine<S>(this IEnumerable<DataRow> first, IEnumerable<DataRow> second, System.Func<DataRow, DataRow, S> func)
{
    using (IEnumerator<DataRow> e1 = first.GetEnumerator(), e2 = second.GetEnumerator())
    {
        while (e1.MoveNext() && e2.MoveNext())
        {
            yield return func(e1.Current, e2.Current);
        }
    }
}

var numbersA = testDS.Tables["NumbersA"].AsEnumerable();
var numbersB = testDS.Tables["NumbersB"].AsEnumerable();

int dotProduct = numbersA.Combine(numbersB, (a, b) => a.Field<int>("number") * b.Field<int>("number")).Sum();
```

## Query Execution

These samples show different concepts of Query Execution.

### Deferred Execution

The following sample shows how query execution is deferred until the query is enumerated at a foreach statement.

```csharp
// Queries are not executed until you enumerate over them.
int[] numbers = new int[] { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };

int i = 0;
var simpleQuery =
    from num in numbers
    select ++i;

// The local variable 'i' is not incremented
// until the query is executed in the foreach loop.
Console.WriteLine("The current value of i is {0}", i); //i is still zero

foreach (var item in simpleQuery)
{
    Console.WriteLine("v = {0}, i = {1}", item, i); // now i is incremented          
}
```

### Immediate Execution

The following sample shows how queries can be executed immediately with operators such as `ToList()`.

```csharp
// Methods like ToList(), Max(), and Count() cause the query to be
// executed immediately.            
int[] numbers = new int[] { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };

int i = 0;
var immediateQuery = (
    from num in numbers
    select ++i)
    .ToList();

Console.WriteLine("The current value of i is {0}", i); //i has been incremented

foreach (var item in immediateQuery)
{
    Console.WriteLine("v = {0}, i = {1}", item, i);
}
```

### Query Reuse

The following sample shows how, because of deferred execution, queries can be used again after data changes and will then operate on the new data.

```csharp
// Deferred execution lets us define a query once
// and then reuse it later in various ways.
int[] numbers = new int[] { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };
var lowNumbers =
    from num in numbers
    where num <= 3
    select num;

Console.WriteLine("First run numbers <= 3:");
foreach (int n in lowNumbers)
{
    Console.WriteLine(n);
}

// Query the original query.
var lowEvenNumbers =
    from num in lowNumbers
    where num % 2 == 0
    select num;

Console.WriteLine("Run lowEvenNumbers query:");
foreach (int n in lowEvenNumbers)
{
    Console.WriteLine(n);
}

// Modify the source data.
for (int i = 0; i < 10; i++)
{
    numbers[i] = -numbers[i];
}

// During this second run, the same query object,
// lowNumbers, will be iterating over the new state
// of numbers[], producing different results:
Console.WriteLine("Second run numbers <= 3:");
foreach (int n in lowNumbers)
{
    Console.WriteLine(n);
}
```

## Join Operators

These samples show different uses of Join Operators.

### Cross Join

This sample shows how to perform a simple inner equijoin of two sequences to produce a flat result set that consists of each element in suppliers that has a matching element in customers.

```csharp
List<Customer> customers = GetCustomerList();
List<Supplier> suppliers = GetSupplierList();

var custSupJoin =
    from sup in suppliers
    join cust in customers on sup.Country equals cust.Country
    select new { Country = sup.Country, SupplierName = sup.SupplierName, CustomerName = cust.CompanyName };

foreach (var item in custSupJoin)
{
    Console.WriteLine("Country = {0}, Supplier = {1}, Customer = {2}", item.Country, item.SupplierName, item.CustomerName);
}
```

### Group Join

A group join produces a hierarchical sequence. The following query is an inner join that produces a sequence of objects, each of which has a key and an inner sequence of all matching elements.

```csharp
List<Customer> customers = GetCustomerList();
List<Supplier> suppliers = GetSupplierList();

var custSupQuery =
    from sup in suppliers
    join cust in customers on sup.Country equals cust.Country into cs
    select new { Key = sup.Country, Items = cs };


foreach (var item in custSupQuery)
{
    Console.WriteLine(item.Key + ":");
    foreach (var element in item.Items)
    {
        Console.WriteLine("   " + element.CompanyName);
    }
}
```

### Group Join - 2

The group join operator is more general than join, as this slightly more verbose version of the cross join sample shows.

```csharp
string[] categories = new string[]{ 
"Beverages", 
"Condiments", 
"Vegetables", 
"Dairy Products", 
"Seafood" };

List<Product> products = GetProductList();

var prodByCategory =
    from cat in categories
    join prod in products on cat equals prod.Category into ps
    from p in ps
    select new { Category = cat, p.ProductName };

foreach (var item in prodByCategory)
{
    Console.WriteLine(item.ProductName + ": " + item.Category);
}
```

### Left Outer Join

A left outer join produces a result set that includes all the left hand side elements at least once, even if they don't match any right hand side elements.

```csharp
List<Customer> customers = GetCustomerList();
List<Supplier> suppliers = GetSupplierList();

var supplierCusts =
    from sup in suppliers
    join cust in customers on sup.Country equals cust.Country into cs
    from c in cs.DefaultIfEmpty()  // DefaultIfEmpty preserves left-hand elements that have no matches on the right side 
    orderby sup.SupplierName
    select new
    {
        Country = sup.Country,
        CompanyName = c == null ? "(No customers)" : c.CompanyName,
        SupplierName = sup.SupplierName
    };

foreach (var item in supplierCusts)
{
    Console.WriteLine("{0} ({1}): {2}", item.SupplierName, item.Country, item.CompanyName);
}
```

## Join With Projection

For each customer in the table of customers, this query returns all the suppliers from that same country, or else a string indicating that no suppliers from that country were found.

```csharp
List<Customer> customers = GetCustomerList();
List<Supplier> suppliers = GetSupplierList();

var custSuppliers =
    from cust in customers
    join sup in suppliers on cust.Country equals sup.Country into ss
    from s in ss.DefaultIfEmpty()
    orderby cust.CompanyName
    select new
    {
        Country = cust.Country,
        CompanyName = cust.CompanyName,
        SupplierName = s == null ? "(No suppliers)" : s.SupplierName
    };

foreach (var item in custSuppliers)
{
    Console.WriteLine("{0} ({1}): {2}", item.CompanyName, item.Country, item.SupplierName);
}
```

## Join With Projection - 2

For each supplier in the table of suppliers, this query returns all the customers from the same city and country, or else a string indicating that no customers from that city/country were found.

Note the use of anonymous types to encapsulate the multiple key values.

```csharp
List<Customer> customers = GetCustomerList();
List<Supplier> suppliers = GetSupplierList();

var supplierCusts =
    from sup in suppliers
    join cust in customers on new { sup.City, sup.Country } equals new { cust.City, cust.Country } into cs
    from c in cs.DefaultIfEmpty() //Remove DefaultIfEmpty method call to make this an inner join
    orderby sup.SupplierName
    select new
    {
        Country = sup.Country,
        City = sup.City,
        SupplierName = sup.SupplierName,
        CompanyName = c == null ? "(No customers)" : c.CompanyName
    };

foreach (var item in supplierCusts)
{
    Console.WriteLine("{0} ({1}, {2}): {3}", item.SupplierName, item.City, item.Country, item.CompanyName);
}
```