---
uti: com.xamarin.workbook
platforms:
- WPF
- MacNet45
---

# Exploring Urho Coordinates

UrhoSharp is a powerful cross-platform 3D graphics engine that Xamarin and .NET developers can use for games or visualization. This workbook is intended as a basic introduction to UrhoSharp and 3D concepts, focusing on the 3D coordinate system.

Currently, the directory in which a UrhoSharp workbook runs must contain the **urho.dll** library as well as **mono-urho.dll** for running the workbook under Windows using the Windows Presentation Foundation (WPF) and the **libmono-urho.dylib** for running the workbook on the Mac.

The workbook itself only needs to reference **Urho.dll**:

```csharp
#r "Urho.dll"
```

This workbook requires only two of the dozen or so namespaces for UrhoSharp types:

```csharp
using Urho;
using Urho.Shapes;
```

If you’re writing a standalone UrhoSharp program using Visual Studio, generally you derive a class from `Application`, and override several methods for all your code, animations, and interaction. The program then instantiates that class and calls the `Run` method on it. The `Run` method is blocking: It doesn’t return until the UrhoSharp application has been terminated.

That architecture would not work very well in an interactive workbook, so a class named `SimpleApplication` is available instead. `SimpleApplication` derives from `Application` and defines an asynchronous static `RunAsync` method that creates the `SimpleApplication` object, performs some initialization, and returns the object, which you can then use for constructing a 3D scene in a workbook. This `SimpleApplication` class does not appear in the online Urho documentation, but you can examine the [source code](https://github.com/xamarin/urho/blob/master/Bindings/Portable/SimpleApplication.cs).

To create a UrhoSharp window in a workbook, call the static asynchronous `SimpleApplication.RunAsync` method using `await`. It’s possible to specify some application options at this time, but the easiest options consist of simply a width and height of a window:

```csharp
SimpleApplication app = await SimpleApplication.RunAsync(1000, 1000);
app.Input.SetMouseVisible(true, true);
```

You should see a window appear on the desktop as the `RunAsync` method completes. The `SetMouseVisible` call ensures that the UrhoSharp window doesn’t take total control of the mouse cursor; otherwise the mouse won’t be visible on your desktop.

## Inside SimpleApplication

The `SimpleApplication` class creates two objects that are essential in a 3D scene: a camera and a light source.

The camera defines how you see 3D objects in the window. The Urho window is similar to the screen of a digital camera or your phone. As you undoubtedly experienced, what you see on a camera screen depends on:

* where the camera is positioned in 3D space,

* the direction that the camera lens is pointed,

* the orientation of the camera (portrait or landscape or something in between), and

* the degree of zoom that you’ve selected

All these characteristics (and more) are part of the Urho3D camera.

This is one way that 3D graphics are different from 2D graphics When working with 2D graphics, generally you specify coordinates relative to a screen or canvas to display something. The coordinate values might be pixels or units that convert to pixels.

With 3D graphics, what you see depends on the the relative locations of the camera and the 3D objects. Coordinate values are all relative. You can increase or decrease all the coordinates and sizes in a 3D scene by a factor of 10 (for example) and everything will look the same.

When you use a camera in real life, you know that you can’t take a picture of something behind the camera or otherwise out of its range. Similarly, in working with 3D scenes, you might not see anything in the UrhoSharp window if the 3D objects are not in the range of the camera. Helping you get a feel for this relationship is one of the goals of this workbook.

The other essential object that `SimpleApplication` creates is a light source. This serves to illuminate 3D objects and provide an illusion of three-dimensional space and curvature.

## A Tree of Nodes

Urho organizes 3D objects in a tree of nodes. Each node (except the root node) has a parent potentially has multiple children. This organization allows you to group related 3D objects and treat them all together. For example, you can move a whole group of objects by moving the parent node. Here’s the documentation of the [`Node` class](https://developer.xamarin.com/api/type/Urho.Node/).

`SimpleApplication` creates a root node, which is a special node of type `Scene`, and which is accessible through the `Scene` property of `SimpleApplication`. Both the camera and light are subnodes of the `Scene` node. (You’ll see shortly how you can access the camera and light source in a workbook.)

The next step is to create a child node of `Scene` that will be used throughout this workbook as a parent (and sometimes a grandparent) to the other nodes:

```csharp
Node mainNode = app.Scene.CreateChild();
```

When you experiment with code in a workbook, the code cells can be executed multiple times. Generally you’ll want to avoid nodes being recreated. For that reason, any code in a workbook that creates a new node should be prefaced with code that removes that node if the code has been run previously. That’s the purpose of the `RemoveAllChildren` call that begins the following code cell:

```csharp
// Avoid multiple identical nodes resulting from re-execution of code cell.
mainNode.RemoveAllChildren();

// Create a node for a Box component
Node boxNode = mainNode.CreateChild();
Box box = boxNode.CreateComponent<Box>();
```

The other two statements demonstrate the simplest way to create a 3D object in the scene. The first step is to create a child node, and then to associate it with a component. (The camera and light created in `SimpleApplication` are components as well.) Notice the generic argument to the `CreateComponent` call. The `Box` component is one of seven classes for basic shapes that derive from the abstract `Shape` class and which can be found in the [`Urho.Shapes` namespace](https://developer.xamarin.com/api/namespace/Urho.Shapes/). The `CreateComponent` method returns an object of type `Box`.

But where is it?

## 3D Space

That `Box` object you’ve just created is not yet visible. Understanding why that is requires some background in 3D coordinate systems.

A 3D graphics system like Urho allows objects to be positioned in a three-dimensional coordinate space. Two of the dimensions are just like a classic Cartesian coordinate system:
![Two-dimensional coordinate system](Figure1.png)

By default the origin is in the center of the Urho window.

A 3D coordinate system has a third axis labeled Z that is at right angles to both the X and Y axis. In Urho, the positive Z axis goes into the screen (conceptually speaking), and the negative Z axis comes out of the screen. Here’s the coordinate system viewed from the left side and above:

![Three-dimensional coordinate system](Figure2.png)
Urho’s coordinate system is known as a *left-hand* system. If you point the forefinger of your left hand in the direction of the positive X coordinates (to the right) and your third finger in the direction of position Y coordinates (up), your thumb points in the direction of positive Z coordinates (into the screen).

It’s sometimes convenient to speak of the coordinate system as defining *planes*. the X and Y axes define the XY plane, while the X and Z axes define the XZ plane, and the Y and Z axes define the YZ plane.

A 3D coordinate point is notated as (x, y, z). The origin of the coordinate system is the point (0, 0, 0).

There’s a good reason why you can’t see the box you created in the Urho window: By default, the camera is positioned at the origin of the 3D coordinate system, and so is the box. The camera is inside the box! The camera needs to come out of the box before it can see the box.

The camera has a direction as well as a position, and by default, it’s pointing in the direction of the positive Z axis, that is, into the screen. Directions are indicated by 3D vectors, which are notated much like 3D points but generally in a bold case. The direction of the camera is the vector **(0, 0, 1)**.

In UrhoSharp, both points and vectors are values of type `Vector3`. The following code shifts the box along the positive Z axis to move it in front of the camera. Notice that `Position` is a property of the `Node` object and not the `Box` object:

```csharp
boxNode.Position = new Vector3(0, 0, 7);
```

And there it is.

It doesn’t look much like a box, however. It looks like a square. The problem now is that the camera is pointed straight at the box, so only one side of the box is visible. You can shift the box to the right by increasing the X coordinate of the `Position`, and to the left by decreasing the X coordinate. You can move the box up by increasing the Y coordinate, and down by decreasing the Y coordinate. Here’s one possibility:

```csharp
boxNode.Position = new Vector3(2, -1.5f, 7);
```

Notice the parameters to the `Vector3` structure are defined as `float` so a f suffix is required for floating point values.

And now it looks more like a box. The camera is still pointing straight down the Z axis, but the box has been moved to the right and down, and you can see the top and left side.

You can probably also tell that the rear of the box is a little smaller on the front. My default, the camera employs a perspective projection which results in objects further from the camera being smaller than those closer to the camera. Urho also supports an orthographic camera, which does not employ projection and makes the 3D object look more like those on an engineering drawing.

## Adjusting the Light

Another contribution to the illusion of three dimensions are the different shades on the three visible sides of the box. `SimpleApplication` creates a directional light source that judging from the different shades, evidently points more towards the positive Z axis than the positive X axis. The top looks black, which means that the light source is not pointing down at all.

However, the light source might be pointing up. Try changing the `Position` to see the bottom of the box.

The `SimpleApplication` class defines a property named `LightNode` that gives you access to the node associated with the light source. You can determine its direction like so:

```csharp
Vector3 lightDirection = app.LightNode.Direction;
```

That seems like an odd number, but it confirms your hunch that it points to the back (the Z axis) more to the right (the X axis), and it doesn’t have a Y component. If you check the source code, you’ll find that the light direction is actually set to the vector **(0.5f, 0, 0.8f)**, but internally the value is normalized so that the magnitude of the vector — the square root of (x² \+ y² \+ z²) — equals 1.

Although the `Direction` property of `Node` does not have a public `set` accessor, you can change the direction of the light by calling the `SetDirection` method:

```csharp
app.LightNode.SetDirection(new Vector3(1, -2, 3));
```

Now you’ll see some light on the top of the box, and more than the light on the left, but less than the light on the front. This is a more “natural” direction to the light. It seems to come from above the viewer’s left shoulder.

## The Camera Field of View

By changing the `Position` property of the `boxNode` object, you can move the box nearer to the camera or further away, and you can move it anywhere around the window. If the box is very close to the camera, you don’t have much leeway in the X and Y coordinates. Try this:

```csharp
boxNode.Position = new Vector3(-1, 0.75f, 3);
```

The box is large because it’s close to the camera, but it’s partially out of the window. Now try this:

```csharp
boxNode.Position = new Vector3(10, 15, 50);
```

The box seems very far away but it’s safely within the window. You can experiment with other values (and you definitely should) to get a feel for this, but you might also have a need to quantify this relationship.

One of the crucial properties of the [`Camera` class](https://developer.xamarin.com/api/type/Urho.Camera/) is named `Fov`, which stands for *field of view*. It’s an angle in degrees, but in practice it’s roughly equivalent to a zoom factor. By default the value is 45 degrees. You can access the `Camera` object that is created by `SimpleApplication` through the `Camera` property. Try changing the `Fov` property to 90:

```csharp
app.Camera.Fov = 90;
```

The box seems to move away. We’ve zoomed out. Try changing it to a value less than 45 degrees to zoom in. When you’re finished experimenting, change it back to the default value of 45 because the rest of this discussion is based on that value:

```csharp
app.Camera.Fov = 45;
```

The camera is located at the origin of the 3D coordinate system and pointing in the direction of the positive Z axis. Viewed from above (from the vantage point of the positive Y axis), the camera’s field of view looks like this:

![Camera Point of View](Figure3.png)

You’d see something similar if you view the camera from the side.

The camera is shown as a little box on the origin, and the field of view is shown as two slanted blue lines. Almost everything between those two blue lines is within the range of the camera and visible within the window. ( But not quite: The range of a perspective camera is actually described by a square frustum. which is a four-sided pyramid with the top shaved off. The `Camera` class defines two properties named `NearClip` and `FarClip` that define a range of distance from the camera that is visible to the camera. By default these properties have values of 0.1 and 1000. In most normal cases, you don’t have to worry about these values, but they’re necessary for the internal camera math to work.)

The diagram above shows the default `Fov` property value of 45 degrees. If you increase the field of view, a larger range becomes visible to the camera. It’s similar to zooming out. You can zoom into a scene by decreasing the field of view.

To quantify the relationship between the distance of an object from the camera and its visual size within the window, draw a line that bisects and Z axis, and label it W for `width`. The distance from that line is labeled D for *distance*:

![Camera Distance and Width](Figure4.png)

Now you’ve defined two similar triangles, and it becomes a problem in trigonometry:

tan(FOV / 2) = (W / 2) / D

or:

W = 2D tan (FOV / 2)

For example, suppose a 3D object is 5 units from the camera. How wide would the object need to be to occupy the full width of the window? If FOV is 45 degrees, the tanget of 22.5 degrees is 0.414, and W equals 4.14 units.

The dimension of the `Box` object is a unit square: 1 unit by 1 unit by 1 unit. The value of the `Position` property corresponds to the center of the `Box`. To position the front of the `Box` five units from the camera, the Z coordinate of the `Position` property must be set to 5.5.

To position the box precisely in the upper-right corner of the window, the X and Y coordinates of the `Position` property must be set to half of W (2.07) minus 0.5:

```csharp
boxNode.Position = new Vector3(1.57f, 1.57f, 5.5f);
```

The `SimpleApplication.RunAsync` call that created the Urho window towards the beginning of this workbook specified square dimensions. This determination of the visual area becomes rather more complex when the window is not square. The translation of 3D coordinates to the 2D coordinates of the window is based on the *height* of the window. Regardless of the window’s aspect ratio, setting the position shown in the code cell above will also position the `Box` object against the top edge of the window. However, the `Box` will be to the left of the right edge of the window if the window has a landscape aspect ratio, and will be partially (or entirely) outside the window or a portrait aspect ratio.

## Exploring Shapes

The following code creates another `Node` with a component that creates a donut-like shape known as a *torus*. Notice that the `CreateChild` call now has an argument, which gives the node a name of “shapeNode”. This name is handy for retrieving the particular node. Indeed, the first statement in this code block removes a node with the name “shapeNode”. That first statement might seem risky to you: If a node with the name “shapeNode” does not exist, `GetChild` returns `null`. Fortunately, if the argument to `RemoveChild` is `null`, it simply does nothing:

```csharp
// Remove node named "shapeNode" so there are no duplicates.
mainNode.RemoveChild(mainNode.GetChild("shapeNode", false));

// Create a node for a Box component
Node shapeNode = mainNode.CreateChild("shapeNode");
Shape shape = shapeNode.CreateComponent<Torus>();
```

Now that’s interesting! The camera is sitting in the middle of the torus (the donut hole) and part of the torus is visible from that perspective.

To see the whole torus, you can change its position (as with the box) but another solution is to change the position of the camera. This statement moves the camera back along the negative Z axis, as well as moving it to the left and up:

```csharp
app.CameraNode.Position = new Vector3(-1, 1.5f, -6);
```

After running that code, you might have expected the torus to remain in the center of the screen. But keep in mind that the camera is still pointed in the positive Z direction. To position the torus in the center of the screen, the camera must be pointed at the origin of the coordinate system.

Pointing the camera at the origin is actually easier than it might seem. The vector that points from position to another is the difference between the coordinates. You can calculate the vector that points from the camera to the origin by subtracting the camera position from the origin, which is the point (0, 0, 0). This is equivalent to the negative of the camera position:

```csharp
app.CameraNode.SetDirection(-app.CameraNode.Position);
```

That code will always point the camera to the 3D origin. And now the torus is in the center of the screen.

Try the other shapes in the code cell above that obtains the `shape` object from the `CreateComponent` generic function. They are: `Cone`, `Cylinder`, `Plane`, `Pyramid`, and `Sphere`. For `Plane` you’ll need to fully qualify the class name: `Urho.Shapes.Plane`.

Of course, you can change the color of this object. The color is not something common to all nodes, so it’s not a `Node` property. Instead, set the `Color` property of the `Shape` object. Several static fields are availble for common colors:

```csharp
shape.Color = Color.Cyan;
```

Or, you can use a constructor of the `Color` structure:

```csharp
shape.Color = new Color(0.5f, 1.0f, 0.25f, 1);
```

The arguments range from 0 to 1 and are in the order red, green, blue, and alpha, which governs transparency.

Before proceeding to the next section, move whatever shape you’re now looking at away from the origin:

```csharp
shapeNode.Position = new Vector3(-2, 2, 10);
```

## Translation, Scaling, and Rotation

The following code positions a cylinder on the origin:

```csharp
// Remove node named "shapeNode" so there are no duplicats.
mainNode.RemoveChild(mainNode.GetChild("cylinderNode", false));

// Create a node for a Box component
Node cylinderNode = mainNode.CreateChild("cylinderNode");
Cylinder cylinder = cylinderNode.CreateComponent<Cylinder>();
```

The cylinder is one unit tall and has a one unit diameter. But what do you do you want a cylinder of a different size or proportions? Or perhaps you need to tip it over so that the ends are parallel to the YZ plane rather than the XZ plane.

These are jobs for graphics *transforms*, of which there are three basic types:

* Translation: change the location of an object

* Scaling: change the size of an object

* Rotation: change the orientation of an object

Very often you’ll combine these transforms.

The transforms are applied to the `Node` object, and they affect all the node’s children. This feature allows you to create a composite object and move, scale, or rotate it as a whole.

The three properties that you set to realize these transforms are:

* `Position` of type `Vector3`, which you’ve already seen

* `Scale` of type `Vector3`

* `Rotation` of type `Quaternion`

There are also some methods that you can use for transforms. For example, the `Translate` method changes the `Position` property, but the effect is accumulative: Every time you call `Translate`,  the `Position` property is changed by that amount.

Similarly, the `ScaleNode` method is accumulative but the `SetScale` method is not. The `Pitch`, `Yaw`, and `Roll` methods are named after terms used in aerodynamics and perform accumulative rotations around the X, Y, and Z axes, respectively.

Transforms can often be difficult to understand, and rotations in particular can be very complex. This discussion is intended as a brief introduction.

The default `Scale` property is the `Vector3` value (1, 1, 1). You can control the scaling factors on all three dimensions independently. Set them to values greater than 1 to increase the size. For example, the value 2 doubles the size in that dimension. Set them to values less than 1 to decrease the size.

For example, suppose you want to make the cylinder skinnier but double the length:

```csharp
cylinderNode.Scale = new Vector3(0.1f, 2, 0.1f);
```

It’s necessary to set the X and Z scaling factors to the same values if you want to keep the cylinder round, but nothing prevents you from setting them to different values for an elliptical cylindar.

Watch out: The default `Scale` property is (1, 1, 1) and not (0, 0, 0). If you set `Scale` to (0, 0, 0), the object will disappear.

Rotations in three dimensions is an exceptionally complex topic, which you might have discerned from the type of the `Rotation` property being the `Quaternion` structure. A quaternion is indeed a mathematical descripton of a 3D rotation that is difficult to grasp intuitively, mostly because it involves three different types of imaginary numbers. The big advantage of quaternions in 3D computer graphics is that they interpolate well, and lend themselves to smooth animations.

Fortunately, there are simpler ways to describe 3D rotation. Perhaps easiest to visualize is the axis-angle rotation. You specify an axis, for instance, the X axis which has a value of (1, 0, 0), and specify a rotational angle around that axis. A simple static method converts that rotation into a Quaternion value.

Often you’ll want to rotate something around the X, Y, or Z axis. The `Vector3` structure defines three static readonly fields named `UnitX`, `UnitY`, and `UnitZ` which equal (1, 0, 0), (0, 1, 0), and (0, 0, 1), respectively. Here’s how to rotate the cylinder 45 degrees around the Z axis:

```csharp
cylinderNode.Rotation = Quaternion.FromAxisAngle(Vector3.UnitZ, 45);
```

You can predict the direction of rotation for positive angles from another left hand rule: Point the thumb of your left hand in the direction of the axis of rotation (in this case the postive Z axis). The fingers of your hand curl in the direction of positive rotation angles.  You can change the direction by changing the sign of the rotation angle, or the direction of the axis.

You can now set the `Position` property to shift the cylinder so the bottom end is at the origin:

```csharp
cylinderNode.Position = new Vector3(-0.707f, 0.707f, 0);
```

Before continuing, move the cylinder to the background:

```csharp
cylinderNode.Position = new Vector3(-0.707f, 0.707f, 12);
```

## Displaying the Axes

The manipulation of the cylinder suggests that thin cylinders might be used to draw some rudimentary straight lines in 3D space. Here’s a function that accepts a `Node` argument and creates 60 subnodes to  draw the axes of the 3D coordinate system. Each cylinder is scaled to a size of (0.025, 0.90, 0.25) and 10 each are stacked in the positive and negative X, Y, and Z directions:

```csharp
void CreateAxes(Node axesNode)
{
    Vector3[] unitVectors = { Vector3.UnitX, Vector3.UnitY, Vector3.UnitZ };

    foreach (Vector3 unitVector in unitVectors)
    {
        for (int i = -10; i < 10; i++)
        {
            Node node = axesNode.CreateChild();
            Cylinder cylinder = node.CreateComponent<Cylinder>();
            cylinder.Color = Color.Black;
            cylinder.CastShadows = false;
            node.Scale = new Vector3(0.025f, 0.90f, 0.025f);

            if (unitVector == Vector3.UnitX)
            {
                node.Rotation = Quaternion.FromAxisAngle(Vector3.UnitZ, 90);
            }
            else if (unitVector == Vector3.UnitZ)
            {
                node.Rotation = Quaternion.FromAxisAngle(Vector3.UnitX, 90);
            }
            node.Position = (i + 0.5f) * unitVector;
        }
    }
}
```

Very little in this function should be new. The `CastShadows` property of the `Cylinder` is set to false; this prevents the axes from casting shadows on other objects. Also, notice how the `Position` property of each `Node` is set: The `Vector3` structure supports multiplication of a vector by a number, often called a scalar in this context.  The number is multiplied by all three components of the vector, but in this case two of them are zero.

To render these axes, create a child node and pass it to the CreateAxes function:

```csharp
// Remove node named "axesNode" so there are no duplicates
mainNode.RemoveChild(mainNode.GetChild("axesNode", false));

// Create node for axes
Node axesNode = mainNode.CreateChild("axesNode");
CreateAxes(axesNode);
```

Now move the `Box` object so that the front left bottom corner is aligned with the origin:

```csharp
boxNode.Position = new Vector3(0.5f, 0.5f, 0.5f);
```

There’s nothing that prevents multiple 3D objects from occupying the same space. Only unobscured surfaces are rendered, so if part of one 3D object is inside another, the hidden surfaces are simply not drawn. The box hides a quarter sliver of each of the three cylinders that it abuts.

This workbook has introduced you to the Urho 3D coordinate system, and the best way to get more familiar with it is by experimentation with these shapes and by creating others.